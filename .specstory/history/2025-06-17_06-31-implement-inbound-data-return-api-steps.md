<!-- Generated by SpecStory -->

# Implement inbound data return API steps (2025-06-17 14:31:16)

_**User**_

@Codebase 現在要再來做 "收貨數據回傳" API接口。
基本上規範都與既有程式相同，只差在Mapping table 改成 zen_b2b_json_receive。
JSON請求的範例 已附上 及 ZEN_B2B_JSON_RECEIVE table Schema 如下

  CREATE TABLE "B2B"."ZEN_B2B_JSON_RECEIVE" 
   (	"SEQ_ID" NUMBER NOT NULL ENABLE, 
	"SENDER_CODE" VARCHAR2(30 BYTE), 
	"RECEIVER_CODE" VARCHAR2(30 BYTE), 
	"CREATION_DATE" DATE, 
	"REF_NO" VARCHAR2(50 BYTE), 
	"WMS_NO" VARCHAR2(30 BYTE), 
	"WMS_UUID" VARCHAR2(30 BYTE), 
	"ARRIVED_TIME" VARCHAR2(50 BYTE), 
	"BUSI_DATE" VARCHAR2(15 BYTE), 
	"BATCH_NO" VARCHAR2(50 BYTE), 
	"BIN_CODE" VARCHAR2(50 BYTE), 
	"DATE_CODE" VARCHAR2(20 BYTE), 
	"INVOICE_NO" VARCHAR2(1000 BYTE), 
	"LOT_NO" VARCHAR2(50 BYTE), 
	"PO_NO" VARCHAR2(100 BYTE), 
	"QTY" VARCHAR2(15 BYTE), 
	"REF_SKU_CODE" VARCHAR2(50 BYTE), 
	"SKU_CODE" VARCHAR2(100 BYTE), 
	"STOCK_UUID" VARCHAR2(50 BYTE), 
	"STORE_CATE" VARCHAR2(50 BYTE), 
	"WMS_LIST_ID" VARCHAR2(20 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 0 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;

請先統整出一步步要做的步驟，再一步一步讓我確認再開始做。

---

_**Assistant**_



---

好的，收到您的需求。我們要建立一個新的「收貨數據回傳」API，這個 API 的功能與現有的「出庫單發運」API 非常相似，但會將資料存入不同的資料表 (`ZEN_B2B_JSON_RECEIVE`)。

根據您的需求、提供的 JSON 範例以及資料庫 Schema，我規劃了以下實作步驟。請您檢視，我們可以一步一步進行。

**第一步：建立新的資料傳輸物件 (DTOs)**

為了對應新的 JSON 結構，我們需要建立一組新的 DTO 類別。這會跟現有的 `InboundOrder` 系列 DTO 很像。

1.  `InboundReceiveDetail.java`: 用來定義 `detail` 陣列中每個物件的欄位，例如 `batch_no`, `date_code`, `qty` 等。
2.  `InboundReceiveData.java`: 用來定義 `data` 物件的結構，它會包含 `ref_no`, `wms_no`, `arrived_time` 以及一個 `InboundReceiveDetail` 的列表。
3.  `InboundReceiveRequest.java`: 用來定義最外層的請求結構，包含 `sign`, `part_code`, `request_time`, 和 `data` 物件。

**第二步：擴充 Repository 功能**

我們需要在 `InboundOrderRepository` 中增加一個新方法，用來將資料寫入 `B2B.ZEN_B2B_JSON_RECEIVE` 資料表。

1.  在 `InboundOrderRepository.java` 中新增 `saveJsonReceive()` 方法。此方法會接收解析後的請求資料，並執行 `INSERT` SQL 命令。
2.  現有的 `saveEnvelope()` 方法也需要稍微調整，使其能夠處理不同的訊息類型 (例如 'SHIP' vs 'RECEIVE') 和不同的文件日期來源。我們可以為它增加參數來傳遞這些資訊。

**第三步：建立新的 Service 處理業務邏輯**

我們會建立一個新的 Service `InboundReceiveService.java` 來封裝所有與「收貨數據」相關的業務邏輯，以保持職責分離。

1.  這個 Service 會複製 `InboundOrderService` 的大部分結構。
2.  它將負責驗證簽名、查找發送方代碼 (`senderCode`)、獲取唯一的 `SEQ_ID`。
3.  它會呼叫 `saveEnvelope()` (並傳入 'RECEIVE' 作為訊息類型) 和新的 `saveJsonReceive()` 方法來儲存資料。
4.  處理完成後，它會呼叫 `EmailService` 發送成功通知郵件。

**第四步：建立新的 API Controller**

最後，我們會建立一個新的 Controller 來向外部公開這個 API。

1.  建立 `InboundReceiveController.java`。
2.  定義 API 端點 (Endpoint)，例如 `/api/inbound-receive`。
3.  這個 Controller 會接收 `POST` 請求，並將請求內容傳遞給 `InboundReceiveService` 進行處理。

**重構建議 (可選)**
由於兩個 Service (`InboundOrderService` 和 `InboundReceiveService`) 有很多共通的程式碼，在完成功能後，我們可以考慮將這些共通邏輯（如簽章驗證、取得 `SEQ_ID` 等）抽到一個共用的父類別或輔助類別中，以減少重複程式碼並提升未來的可維護性。

請先確認以上規劃的步驟是否符合您的預期？如果同意，我們就可以從第一步開始著手。

---

_**User**_

同意

---

_**Assistant**_



---

好的，我們開始第一步。

我將在 `src/main/java/com/zenitron/znt_inbound_api/dto/` 目錄下建立三個新的 DTO 檔案，以對應「收貨數據回傳」API 的 JSON 請求結構。

1.  `InboundReceiveDetail.java`: 對應 `detail` 陣列中的物件。
2.  `InboundReceiveData.java`: 對應 `data` 物件。
3.  `InboundReceiveRequest.java`: 對應整個請求的結構。

這三個檔案的程式碼如下：

```java:src/main/java/com/zenitron/znt_inbound_api/dto/InboundReceiveDetail.java
package com.zenitron.znt_inbound_api.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import jakarta.validation.constraints.NotBlank;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class InboundReceiveDetail {

    @JsonProperty("batch_no")
    private String batchNo;

    @JsonProperty("bin_code")
    private String binCode;

    @JsonProperty("date_code")
    private String dateCode;

    @JsonProperty("invoice_no")
    private String invoiceNo;

    @JsonProperty("lot_no")
    private String lotNo;

    @JsonProperty("po_no")
    private String poNo;

    @NotBlank(message = "qty 不得為空")
    @JsonProperty("qty")
    private String qty;

    @JsonProperty("ref_sku_code")
    private String refSkuCode;

    @NotBlank(message = "sku_code 不得為空")
    @JsonProperty("sku_code")
    private String skuCode;

    @JsonProperty("stock_uuid")
    private String stockUuid;

    @JsonProperty("store_cate")
    private String storeCate;

    @JsonProperty("wms_list_id")
    private String wmsListId;
}
```

```java:src/main/java/com/zenitron/znt_inbound_api/dto/InboundReceiveData.java
package com.zenitron.znt_inbound_api.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import jakarta.validation.Valid;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotEmpty;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class InboundReceiveData {

    @NotBlank(message = "ref_no 不得為空")
    @JsonProperty("ref_no")
    private String refNo;

    @JsonProperty("wms_no")
    private String wmsNo;

    @JsonProperty("wms_uuid")
    private String wmsUuid;

    @JsonProperty("arrived_time")
    private String arrivedTime;

    @JsonProperty("busi_date")
    private String busiDate;

    @NotEmpty(message = "detail 列表不得為空")
    @Valid
    @JsonProperty("detail")
    private List<InboundReceiveDetail> detail;
}
```

```java:src/main/java/com/zenitron/znt_inbound_api/dto/InboundReceiveRequest.java
package com.zenitron.znt_inbound_api.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import jakarta.validation.Valid;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class InboundReceiveRequest {

    @NotBlank(message = "sign 不得為空")
    @JsonProperty("sign")
    private String sign;

    @NotBlank(message = "part_code 不得為空")
    @JsonProperty("part_code")
    private String partCode;

    @NotBlank(message = "request_time 不得為空")
    @JsonProperty("request_time")
    private String requestTime;

    @NotNull(message = "data 不得為 null")
    @Valid
    @JsonProperty("data")
    private InboundReceiveData data;
}
```

我已經將這三個檔案建立完成。

接下來，我們進行**第二步：擴充 Repository 功能**。
這一步我們將在 `InboundOrderRepository.java` 中新增一個 `saveJsonReceive()` 方法，用來將收貨資料寫入 `ZEN_B2B_JSON_RECEIVE` 資料表。

您準備好繼續了嗎？

---

_**User**_

準備好了。

---

_**Assistant**_



---

好的，我們繼續進行第二步。

我將在 `InboundOrderRepository.java` 中新增一個 `saveJsonReceive` 方法。這個方法會負責將傳入的收貨資料，寫入 `B2B.ZEN_B2B_JSON_RECEIVE` 資料表中。

這是對 `src/main/java/com/zenitron/znt_inbound_api/repository/InboundOrderRepository.java` 的修改：

```java:src/main/java/com/zenitron/znt_inbound_api/repository/InboundOrderRepository.java
// ... existing code ...
import com.zenitron.znt_inbound_api.dto.InboundOrderData;
import com.zenitron.znt_inbound_api.dto.InboundOrderDetail;
import com.zenitron.znt_inbound_api.dto.InboundReceiveData;
import com.zenitron.znt_inbound_api.dto.InboundReceiveDetail;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
// ... existing code ...
    public void saveJsonShip(Long seqId, String senderCode, Date creationDate, InboundOrderData data, InboundOrderDetail detail) {
// ... existing code ...
                detail.getStockMode(),
                detail.getStockUuid()
        );
    }

    public void saveJsonReceive(Long seqId, String senderCode, Date creationDate, InboundReceiveData data, InboundReceiveDetail detail) {
        String sql = "INSERT INTO B2B.ZEN_B2B_JSON_RECEIVE (" +
                "SEQ_ID, SENDER_CODE, RECEIVER_CODE, CREATION_DATE, REF_NO, WMS_NO, WMS_UUID, ARRIVED_TIME, BUSI_DATE, " +
                "BATCH_NO, BIN_CODE, DATE_CODE, INVOICE_NO, LOT_NO, PO_NO, QTY, REF_SKU_CODE, SKU_CODE, STOCK_UUID, " +
                "STORE_CATE, WMS_LIST_ID) " +
                "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";

        jdbcTemplate.update(sql,
                seqId,
                senderCode,
                "ZEN", // RECEIVER_CODE
                creationDate,
                data.getRefNo(),
                data.getWmsNo(),
                data.getWmsUuid(),
                data.getArrivedTime(),
                data.getBusiDate(),
                detail.getBatchNo(),
                detail.getBinCode(),
                detail.getDateCode(),
                detail.getInvoiceNo(),
                detail.getLotNo(),
                detail.getPoNo(),
                detail.getQty(),
                detail.getRefSkuCode(),
                detail.getSkuCode(),
                detail.getStockUuid(),
                detail.getStoreCate(),
                detail.getWmsListId()
        );
    }

    /**
     * 根據 part_code (TD_NAME) 反向查找發送方代碼 (例如 "FEILIKS")。
// ... existing code ...
```

我已經在 `InboundOrderRepository` 中加入了 `saveJsonReceive` 方法，並添加了所需的 DTO 類別的 `import` 語句。

接下來我們將進行**第三步：建立新的 Service `InboundReceiveService.java` 來處理業務邏輯**。這將會是新 API 的核心部分。

準備好後請告訴我，我們就繼續。

---

_**User**_

你上述說明步驟時有提到
現有的 saveEnvelope() 方法也需要稍微調整，使其能夠處理不同的訊息類型 (例如 'SHIP' vs 'RECEIVE') 和不同的文件日期來源。我們可以為它增加參數來傳遞這些資訊。

---

_**Assistant**_



---

您提的完全正確，感謝您的提醒！我確實遺漏了修改 `saveEnvelope` 方法這一步。為了讓 `saveEnvelope` 方法可以同時處理「出庫單」和「收貨單」，我們需要對它進行重構，讓它變得更通用。

我的計畫如下：
我會修改 `saveEnvelope` 的方法簽名，不再直接傳入 `InboundOrderRequest` 物件，而是將所有需要的欄位（如 `partCode`, `refNo`, `wmsNo` 等）以及一個新的 `messageType` 參數（用來區分 'SHIP' 或 'RECEIVE'）分別傳入。

這樣一來，無論是舊的 `InboundOrderService` 還是我們即將建立的 `InboundReceiveService` 都可以呼叫同一個方法來寫入 `ZEN_B2B_ENVELOPE` 資料表，避免了程式碼重複。

以下是相關檔案的程式碼變更：

首先，是 `InboundOrderRepository.java`，我們將更新 `saveEnvelope` 方法：

```java:src/main/java/com/zenitron/znt_inbound_api/repository/InboundOrderRepository.java
// ... existing code ...
import com.zenitron.znt_inbound_api.dto.InboundOrderData;
import com.zenitron.znt_inbound_api.dto.InboundOrderDetail;
import com.zenitron.znt_inbound_api.dto.InboundReceiveData;
import com.zenitron.znt_inbound_api.dto.InboundReceiveDetail;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
// ... existing code ...
                detail.getSkuCode(),
                detail.getStockMode(),
                detail.getStockUuid()
        );
    }

    public void saveJsonReceive(Long seqId, String senderCode, Date creationDate, InboundReceiveData data, InboundReceiveDetail detail) {
// ... existing code ...
                detail.getStoreCate(),
                detail.getWmsListId()
        );
    }

    public void saveEnvelope(Long seqId, String senderCode, String partCode, String sign, String requestTime,
                             String refNo, String wmsNo, String wmsUuid, String busiDate,
                             String messageType, Date docDateTime) {
        String sql = "INSERT INTO B2B.ZEN_B2B_ENVELOPE (" +
                "SEQ_ID, SENDER_CODE, RECEIVER_CODE, SENDER_AP_ID, RECEIVER_AP_ID, SENDER_GS_ID, RECEIVER_GS_ID, " +
                "INTERCHANGE_NO, GROUP_NO, TRANSACTION_NO, DOC_NO, DOC_ID, DIRECTION, B2B_MSG_TYPE, DATASOURCE, " +
                "DOC_DATETIME, BATCH_PROCESS_ID, TRANS_FLAG, CONVERSATION_ID, CREATION_DATE, LAST_UPDATE_DATE, " +
                "REF_NO1, REF_NO2) " +
                "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";

        Date now = new Date();

        jdbcTemplate.update(sql,
                seqId,                          // SEQ_ID
                senderCode,                     // SENDER_CODE
                "ZEN",                          // RECEIVER_CODE
                partCode,                       // SENDER_AP_ID
                "ZEN",                          // RECEIVER_AP_ID
                senderCode,                     // SENDER_GS_ID
                "ZEN",                          // RECEIVER_GS_ID
                null,                           // INTERCHANGE_NO
                null,                           // GROUP_NO
                refNo,                          // TRANSACTION_NO
                wmsNo,                          // DOC_NO
                String.valueOf(seqId),          // DOC_ID
                "IN",                           // DIRECTION
                messageType,                    // B2B_MSG_TYPE
                "EDI",                          // DATASOURCE
                docDateTime,                    // DOC_DATETIME
                wmsUuid,                        // BATCH_PROCESS_ID
                "S",                            // TRANS_FLAG
                sign,                           // CONVERSATION_ID
                now,                            // CREATION_DATE
                now,                            // LAST_UPDATE_DATE
                requestTime,                    // REF_NO1
                busiDate                        // REF_NO2
        );
    }
}
```

接著，我們需要更新 `InboundOrderService.java` 中對 `saveEnvelope` 的呼叫方式：

```java:src/main/java/com/zenitron/znt_inbound_api/service/InboundOrderService.java
// ... existing code ...
        Date shippedTime = parseDate(data.getShippedTime(), "shipped_time", false);

        // 寫入 ENVELOPE 表
        inboundOrderRepository.saveEnvelope(
                seqId,
                senderCode,
                request.getPartCode(),
                request.getSign(),
                request.getRequestTime(),
                data.getRefNo(),
                data.getWmsNo(),
                data.getWmsUuid(),
                data.getBusiDate(),
                "SHIP", // messageType
                shippedTime // docDateTime
        );

        // 寫入 JSON_SHIP 表 (明細)
        Date jsonCreationDate = new Date();
// ... existing code ...
```

這樣修改後，Repository 層就準備好了。

如果沒有問題，我們就可以繼續進行**第三步：建立新的 `InboundReceiveService.java`**。

---

_**User**_

沒有問題

---

_**Assistant**_



---

好的，我們來進行第三步：建立新的 `InboundReceiveService.java`。

這個 Service 將會處理「收貨數據」的主要業務邏輯，包含驗證簽名、儲存資料到資料庫，以及觸發郵件通知。它的結構會和現有的 `InboundOrderService` 非常相似。

同時，為了確保簽名驗證的正確性，我會一併更新先前建立的 `InboundReceiveData.java` 和 `InboundReceiveDetail.java`，為它們加上 `@JsonPropertyOrder` 註解。這能保證我們的後端在計算簽名時，JSON 欄位的順序會和客戶端完全一致。

以下是將要建立與修改的檔案：

首先，是建立新的 Service 檔案 `InboundReceiveService.java`:
```java:src/main/java/com/zenitron/znt_inbound_api/service/InboundReceiveService.java
package com.zenitron.znt_inbound_api.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.MapperFeature;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.json.JsonMapper;
import com.zenitron.znt_inbound_api.dto.InboundReceiveData;
import com.zenitron.znt_inbound_api.dto.InboundReceiveDetail;
import com.zenitron.znt_inbound_api.dto.InboundReceiveRequest;
import com.zenitron.znt_inbound_api.exception.SignatureVerificationException;
import com.zenitron.znt_inbound_api.repository.InboundOrderRepository;
import com.zenitron.znt_inbound_api.repository.PartnerKeyRepository;
import org.apache.commons.codec.binary.Base64;
import org.apache.commons.codec.digest.DigestUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.nio.charset.StandardCharsets;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.List;

@Service
public class InboundReceiveService {

    private static final Logger logger = LoggerFactory.getLogger(InboundReceiveService.class);

    private final PartnerKeyRepository partnerKeyRepository;
    private final InboundOrderRepository inboundOrderRepository;
    private final EmailService emailService;

    @Autowired
    public InboundReceiveService(PartnerKeyRepository partnerKeyRepository, InboundOrderRepository inboundOrderRepository, EmailService emailService) {
        this.partnerKeyRepository = partnerKeyRepository;
        this.inboundOrderRepository = inboundOrderRepository;
        this.emailService = emailService;
    }

    @Transactional
    public void processInboundReceive(InboundReceiveRequest request) {
        verifySignature(request);

        String senderCode = partnerKeyRepository.findSenderCodeByPartCode(request.getPartCode())
                .orElseThrow(() -> {
                    logger.error("無法從 part_code '{}' 反向查找 sender code", request.getPartCode());
                    return new IllegalStateException("伺服器內部錯誤：無法解析發送方代碼");
                });

        Date jsonCreationDate = new Date(); // Use current date for CREATION_DATE in the detail table

        InboundReceiveData data = request.getData();
        Date arrivedTime = parseDate(data.getArrivedTime(), "arrived_time", false);

        // 1. 為此請求獲取一個唯一的 SEQ_ID
        Long seqId = inboundOrderRepository.getNextSeqId();

        // 2. 將 Envelope 資料寫入，每個請求只寫一次
        inboundOrderRepository.saveEnvelope(
                seqId,
                senderCode,
                request.getPartCode(),
                request.getSign(),
                request.getRequestTime(),
                data.getRefNo(),
                data.getWmsNo(),
                data.getWmsUuid(),
                data.getBusiDate(),
                "RECEIVE", // messageType
                arrivedTime // docDateTime
        );

        // 3. 遍歷所有明細，使用相同的 SEQ_ID 寫入 JSON_RECEIVE 表
        for (InboundReceiveDetail detail : data.getDetail()) {
            inboundOrderRepository.saveJsonReceive(seqId, senderCode, jsonCreationDate, data, detail);
        }

        logger.info("成功將 {} 筆資料存入資料庫，參考編號 (ref_no): {}", data.getDetail().size(), data.getRefNo());

        // 發送成功通知郵件
        List<String> recipients = partnerKeyRepository.findRecipientsBySenderCode(senderCode);
        emailService.sendSuccessEmail(recipients, senderCode, data.getRefNo(), data.getWmsNo());

        logger.debug("完整請求內容: {}", request);
    }

    private Date parseDate(String dateString, String fieldName, boolean isRequired) {
        if (dateString == null || dateString.trim().isEmpty()) {
            if (isRequired) {
                throw new SignatureVerificationException(fieldName + " 不得為空");
            }
            return null;
        }
        try {
            SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
            return sdf.parse(dateString);
        } catch (ParseException e) {
            logger.error("無法解析日期欄位 '{}': '{}'", fieldName, dateString, e);
            throw new SignatureVerificationException("日期欄位 '"+ fieldName +"' 格式不正確，應為 'yyyy-MM-dd HH:mm:ss'");
        }
    }

    private void verifySignature(InboundReceiveRequest request) {
        String partCode = request.getPartCode();
        String partnerKey = partnerKeyRepository.findPartnerKeyByPartCode(partCode)
                .orElseThrow(() -> {
                    logger.error("找不到 part_code '{}' 對應的 Partner Key", partCode);
                    return new SignatureVerificationException("無效的 part_code 或找不到對應的金鑰");
                });

        try {
            ObjectMapper objectMapper = JsonMapper.builder()
                    .disable(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY)
                    .build();
            String dataJson = objectMapper.writeValueAsString(request.getData());
            String stringToSign = dataJson + partnerKey;

            String md5Hex = DigestUtils.md5Hex(stringToSign);
            String calculatedSignature = Base64.encodeBase64String(md5Hex.getBytes(StandardCharsets.UTF_8));

            if (!calculatedSignature.equals(request.getSign())) {
                logger.warn("簽名驗證失敗。part_code: {}, 傳入簽名: {}, 計算後簽名: {}", partCode, request.getSign(), calculatedSignature);

                partnerKeyRepository.findSenderCodeByPartCode(partCode).ifPresent(senderCode -> {
                    List<String> recipients = partnerKeyRepository.findRecipientsBySenderCode(senderCode);
                    emailService.sendSignatureErrorEmail(
                        recipients,
                        senderCode,
                        partnerKey,
                        calculatedSignature,
                        request.getSign()
                    );
                });
                
                throw new SignatureVerificationException("簽名驗證失敗");
            }

            logger.info("part_code '{}' 的簽名驗證成功", partCode);

        } catch (JsonProcessingException e) {
            logger.error("將 'data' 物件序列化為 JSON 時發生錯誤", e);
            throw new SignatureVerificationException("請求資料格式錯誤");
        }
    }
}
```

接著，是更新 DTO 檔案，加上 `@JsonPropertyOrder`：

```java:src/main/java/com/zenitron/znt_inbound_api/dto/InboundReceiveData.java
package com.zenitron.znt_inbound_api.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import jakarta.validation.Valid;
import jakarta.validation.constraints.NotBlank;
// ... existing code ...
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
@JsonPropertyOrder({
    "ref_no",
    "wms_no",
    "wms_uuid",
    "arrived_time",
    "busi_date",
    "detail"
})
public class InboundReceiveData {

    @NotBlank(message = "ref_no 不得為空")
// ... existing code ...
```

```java:src/main/java/com/zenitron/znt_inbound_api/dto/InboundReceiveDetail.java
package com.zenitron.znt_inbound_api.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import jakarta.validation.constraints.NotBlank;
import lombok.Data;
// ... existing code ...
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@JsonPropertyOrder({
    "batch_no",
    "bin_code",
    "date_code",
    "invoice_no",
    "lot_no",
    "po_no",
    "qty",
    "ref_sku_code",
    "sku_code",
    "stock_uuid",
    "store_cate",
    "wms_list_id"
})
public class InboundReceiveDetail {

    @JsonProperty("batch_no")
    private String batchNo;
// ... existing code ...
```

這樣第三步就完成了。請您確認，如果沒有問題，我們就剩下最後一步：建立新的 Controller。

---

_**User**_

@InboundReceiveService.java 你剛剛產生的code裡，裡面Repository都用成inboundOrderRepository?

---

_**Assistant**_



---

是的，您觀察得很仔細。在 `InboundReceiveService` 中，我確實是使用現有的 `inboundOrderRepository`。

這是一個刻意的設計選擇，原因如下：

1.  **共用資料庫邏輯**：「出庫單 (SHIP)」和「收貨單 (RECEIVE)」這兩個功能雖然處理不同的資料，但它們的底層操作有很多共通之處。例如：
    *   都需要從同一個序列 (`B2B.ZEN_B2B_ENVELOPE_SEQ`) 獲取 `SEQ_ID` (透過 `getNextSeqId` 方法)。
    *   都需要將請求的共通資訊寫入 `ZEN_B2B_ENVELOPE` 表 (透過我們剛剛修改的 `saveEnvelope` 方法)。

2.  **集中管理**：與其建立一個新的、功能非常相似的 `InboundReceiveRepository`，不如將所有與「從外部接收 JSON 資料並存入資料庫」相關的功能都集中在 `InboundOrderRepository` 裡。這樣可以減少類別的數量，也方便未來統一管理所有 inbound 相關的資料庫操作。

我們在上一個步驟中，已經將新的 `saveJsonReceive` 方法和通用的 `saveEnvelope` 方法都加入到 `InboundOrderRepository` 了。所以 `InboundReceiveService` 可以直接注入並使用它來完成所有資料庫存取任務。

簡單來說，我將 `InboundOrderRepository` 視為一個處理所有「Inbound API」相關資料庫操作的通用 Repository，而不是僅僅處理「Order」。

不過，如果您認為將它們分開到一個新的 `InboundReceiveRepository.java` 會更清晰，我們也可以進行調整。我目前的做法是為了最大化程式碼的重用性。

請問您接受這個解釋嗎？如果可以，我們就繼續進行最後一步：建立 Controller。

---

_**User**_

我發現 @EmailService.java 裡 信件標題 有寫死 SHIP，
sendSignatureErrorEmail 如果 今天 是 RECEIVE，則 SHIP 要換成 RECEIVE，
sendSuccessEmail 如果 今天 是 RECEIVE，則 SHIP 字眼要拿掉

---

_**Assistant**_



---

您觀察得非常細緻，這確實是個問題！郵件標題寫死會導致「收貨 (RECEIVE)」API 發送錯誤的通知。我們必須馬上修正它，讓郵件內容能根據 API 類型動態產生。

為了達成這個目標，我會修改 `EmailService` 中的兩個郵件發送方法，讓它們多接收一個 `messageType` 參數 ('SHIP' 或 'RECEIVE')。然後，我會同步更新 `InboundOrderService` 和 `InboundReceiveService` 中呼叫這些方法的地方，傳入正確的類型。

以下是所有相關的程式碼變更：

**1. 修改 `EmailService.java`**

我將更新 `sendSignatureErrorEmail` 和 `sendSuccessEmail` 方法，使其標題可以動態調整。

```java:src/main/java/com/zenitron/znt_inbound_api/service/EmailService.java
// ... existing code ...
        }
        return "";
    }

    public void sendSignatureErrorEmail(List<String> to, String senderCode, String partnerKey, String calculatedSign, String receivedSign, String messageType) {
        if (to == null || to.isEmpty()) {
            logger.warn("簽名驗證失敗，但找不到收件人，不發送郵件。Sender Code: {}", senderCode);
            return;
        }

        try {
            SimpleMailMessage message = new SimpleMailMessage();
            message.setFrom(fromEmail);
            message.setTo(to.toArray(new String[0]));

            String subject = String.format("%sReceive [%s] EDI, %s key : [%s], sign Issue", getEnvironmentPrefix(), senderCode, messageType.toUpperCase(), partnerKey);
            message.setSubject(subject);

            String body = String.format(
                "<<Check Sign>>\n%s\n\n<<JSON Sign>>\n%s\n\n***EDI系統自動通知請勿回覆!***",
                calculatedSign,
                receivedSign
            );
            message.setText(body);

            mailSender.send(message);
            logger.info("已發送簽名錯誤通知郵件至: {}", String.join(", ", to));

        } catch (Exception e) {
            logger.error("發送簽名錯誤通知郵件時發生錯誤。Sender Code: {}", senderCode, e);
        }
    }

    public void sendSuccessEmail(List<String> to, String senderCode, String refNo, String wmsNo, String messageType) {
        if (to == null || to.isEmpty()) {
            logger.warn("資料處理成功，但找不到收件人，不發送成功通知郵件。Sender Code: {}", senderCode);
            return;
        }

        try {
            SimpleMailMessage message = new SimpleMailMessage();
            message.setFrom(fromEmail);
            message.setTo(to.toArray(new String[0]));

            String subject;
            if ("SHIP".equalsIgnoreCase(messageType)) {
                 subject = String.format("%sReceive SHIP REF#[%s],WMS_NO#[%s] from [%s]", getEnvironmentPrefix(), refNo, wmsNo, senderCode);
            } else {
                 subject = String.format("%sReceive REF#[%s],WMS_NO#[%s] from [%s]", getEnvironmentPrefix(), refNo, wmsNo, senderCode);
            }
            message.setSubject(subject);

            String body = "***EDI系統自動通知請勿回覆!***";
            message.setText(body);

            mailSender.send(message);
            logger.info("已發送成功通知郵件至: {}", String.join(", ", to));

        } catch (Exception e) {
            logger.error("發送成功通知郵件時發生錯誤。Sender Code: {}", senderCode, e);
        }
    }
}
```

**2. 更新 `InboundOrderService.java`**

在呼叫郵件服務時，傳入 "SHIP" 作為類型。

```java:src/main/java/com/zenitron/znt_inbound_api/service/InboundOrderService.java
// ... existing code ...
            if (!calculatedSignature.equals(request.getSign())) {
                logger.warn("簽名驗證失敗。part_code: {}, 傳入簽名: {}, 計算後簽名: {}", partCode, request.getSign(), calculatedSignature);

                partnerKeyRepository.findSenderCodeByPartCode(partCode).ifPresent(senderCode -> {
                    List<String> recipients = partnerKeyRepository.findRecipientsBySenderCode(senderCode);
                    emailService.sendSignatureErrorEmail(
                        recipients,
                        senderCode,
                        partnerKey,
                        calculatedSignature,
                        request.getSign(),
                        "SHIP"
                    );
                });
                
                throw new SignatureVerificationException("簽名驗證失敗");
// ... existing code ...
        logger.info("成功將 {} 筆資料存入資料庫，參考編號 (ref_no): {}", data.getDetail().size(), data.getRefNo());

        // 發送成功通知郵件
        List<String> recipients = partnerKeyRepository.findRecipientsBySenderCode(senderCode);
        emailService.sendSuccessEmail(recipients, senderCode, data.getRefNo(), data.getWmsNo(), "SHIP");

        logger.debug("完整請求內容: {}", request);
    }

// ... existing code ...
```

**3. 更新 `InboundReceiveService.java`**

在呼叫郵件服務時，傳入 "RECEIVE" 作為類型。

```java:src/main/java/com/zenitron/znt_inbound_api/service/InboundReceiveService.java
// ... existing code ...
        logger.info("成功將 {} 筆資料存入資料庫，參考編號 (ref_no): {}", data.getDetail().size(), data.getRefNo());

        // 發送成功通知郵件
        List<String> recipients = partnerKeyRepository.findRecipientsBySenderCode(senderCode);
        emailService.sendSuccessEmail(recipients, senderCode, data.getRefNo(), data.getWmsNo(), "RECEIVE");

        logger.debug("完整請求內容: {}", request);
    }

// ... existing code ...
            if (!calculatedSignature.equals(request.getSign())) {
                logger.warn("簽名驗證失敗。part_code: {}, 傳入簽名: {}, 計算後簽名: {}", partCode, request.getSign(), calculatedSignature);

                partnerKeyRepository.findSenderCodeByPartCode(partCode).ifPresent(senderCode -> {
                    List<String> recipients = partnerKeyRepository.findRecipientsBySenderCode(senderCode);
                    emailService.sendSignatureErrorEmail(
                        recipients,
                        senderCode,
                        partnerKey,
                        calculatedSignature,
                        request.getSign(),
                        "RECEIVE"
                    );
                });
                
                throw new SignatureVerificationException("簽名驗證失敗");
// ... existing code ...
```

這樣修改後，郵件通知的邏輯就正確了。

我們現在可以繼續進行最後一步：**建立新的 API Controller**。您準備好了嗎？

---

_**User**_

準備好了

---

_**Assistant**_



---

好的，我們來完成最後一步。

我將在 `src/main/java/com/zenitron/znt_inbound_api/controller/` 路徑下建立一個新的 Controller 檔案 `InboundReceiveController.java`。

這個 Controller 會負責定義新的 API 端點 `/api/inbound-receive`，並將收到的請求轉交給我們剛才建立的 `InboundReceiveService` 處理。

以下是 `InboundReceiveController.java` 的程式碼：

```java:src/main/java/com/zenitron/znt_inbound_api/controller/InboundReceiveController.java
package com.zenitron.znt_inbound_api.controller;

import com.zenitron.znt_inbound_api.dto.InboundReceiveRequest;
import com.zenitron.znt_inbound_api.service.InboundReceiveService;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/inbound-receive")
public class InboundReceiveController {

    private final InboundReceiveService inboundReceiveService;

    @Autowired
    public InboundReceiveController(InboundReceiveService inboundReceiveService) {
        this.inboundReceiveService = inboundReceiveService;
    }

    @PostMapping
    public ResponseEntity<String> receiveInboundData(@Valid @RequestBody InboundReceiveRequest request) {
        inboundReceiveService.processInboundReceive(request);
        return ResponseEntity.ok("收貨數據請求已成功接收");
    }
}
```

至此，我們已經完成了「收貨數據回傳」API 的所有開發步驟：

1.  ✅ **建立 DTOs**: `InboundReceiveRequest`, `InboundReceiveData`, `InboundReceiveDetail` 都已建立。
2.  ✅ **擴充 Repository**: `InboundOrderRepository` 中新增了 `saveJsonReceive` 方法，並將 `saveEnvelope` 方法通用化。
3.  ✅ **建立 Service**: 建立了 `InboundReceiveService` 處理業務邏輯，並修正了 `EmailService` 的郵件標題問題。
4.  ✅ **建立 Controller**: `InboundReceiveController` 已建立，新的 API 端點 `/api/inbound-receive` 現在可以使用了。

整個功能已經建置完成。請問還有其他需要我協助的地方嗎？

---

