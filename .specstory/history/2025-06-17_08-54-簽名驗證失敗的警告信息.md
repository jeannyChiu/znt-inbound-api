<!-- Generated by SpecStory -->

# 簽名驗證失敗的警告信息 (2025-06-17 16:54:57)

_**User**_

測試的時候出現 
2025-06-17T16:50:40.001+08:00  WARN 30548 --- [znt-inbound-api] [nio-8080-exec-3] c.z.z.service.InboundReceiveService      : 簽名驗證失敗。part_code: ZENHUBFEILIKS, 傳入簽名: MDMxYjAzNWRlYzUyN2UyZmE0MjIyOWY3NDk0NzJmNDk=, 計算後簽名: M2ZmODQzYzNjZTNkZGU5Yjc2NTU5YzU2YTdkMTZkYWM=

---

_**Assistant**_



---

您好，從您提供的日誌來看，問題出在簽章的計算結果不一致。伺服器端根據傳入的資料計算出的簽章，與對方傳來的簽章比對後發現不同，因此驗證失敗。

這通常有以下幾個可能的原因：

1.  **參與簽章計算的資料不一致**：
    *   傳送方和接收方使用的**欄位**或**欄位順序**不同。
    *   欄位值的大小寫、前後空白字元、或特殊字元的處理方式不同。
    *   空值（null）或空字串（""）的處理方式不一致。

2.  **`Secret Key` 不匹配**：
    *   日誌中 `part_code: ZENHUBFEILIKS` 所對應的 `secret key` 在您的系統和傳送方的系統中可能設定得不一樣。

3.  **編碼或加密流程不同**：
    *   字串拼接的方式不同。
    *   在進行 MD5 或其他雜湊運算前的字元編碼（如 UTF-8）不一致。
    *   最終雜湊值的格式化方式不同（例如，轉為 Base64 前的大小寫）。

為了能準確地幫您定位問題，可以請您提供 `InboundReceiveService.java` 中負責驗證簽章的相關程式碼區塊嗎？

有了程式碼，我們就可以確認伺服器端的簽章計算邏輯，並與傳送方的計算規則進行比對，找出差異點。

---

_**User**_

@InboundReceiveService.java 

---

_**Assistant**_



---

好的，我已經看過 `InboundReceiveService.java` 的程式碼了。

問題的核心在於 `verifySignature` 方法中，如何將 `request.getData()` 這個物件轉換成 JSON 字串來進行簽章計算。

根據您的程式碼：
```java
ObjectMapper objectMapper = JsonMapper.builder()
        .disable(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY)
        .build();
String dataJson = objectMapper.writeValueAsString(request.getData());
String stringToSign = dataJson + partnerKey;
```
這裡您明確地**停用**了 `SORT_PROPERTIES_ALPHABETICALLY` 這個特性。這代表 `dataJson` 字串中欄位的順序，會依賴您在 `InboundReceiveData` 和 `InboundReceiveDetail` DTO 中定義欄位的順序。

如果傳送方在產生 JSON 時，所使用的欄位順序和您這邊不同（例如，他們可能是按字母順序排序，或是他們 DTO 中的欄位順序不同），那麼雙方產生的 `dataJson` 字串就會不一樣，即使內容完全相同，最終計算出來的簽章也會不同，導致驗證失敗。這是這類 API 串接時非常常見的問題點。

### 建議的修改

最穩健的作法是**啟用字母排序**。這樣可以確保不論是哪一方，只要 `data` 物件內的資料一致，序列化出來的 JSON 字串順序就會永遠相同。

我將為您修改 `verifySignature` 方法：

1.  將 `disable` 改為 `enable(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY)`。
2.  在計算 MD5 時，明確指定使用 `UTF-8` 編碼，避免因不同作業系統平台預設編碼不同而產生問題。

```java:src/main/java/com/zenitron/znt_inbound_api/service/InboundReceiveService.java
// ... existing code ...
    private void verifySignature(InboundReceiveRequest request) {
        String partCode = request.getPartCode();
        String partnerKey = partnerKeyRepository.findPartnerKeyByPartCode(partCode)
                .orElseThrow(() -> {
                    logger.error("找不到 part_code '{}' 對應的 Partner Key", partCode);
                    return new SignatureVerificationException("無效的 part_code 或找不到對應的金鑰");
                });

        try {
            // 啟用字母排序，確保 JSON 欄位順序一致，這點需要與發送方確認
            ObjectMapper objectMapper = JsonMapper.builder()
                    .enable(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY)
                    .build();
            String dataJson = objectMapper.writeValueAsString(request.getData());
            String stringToSign = dataJson + partnerKey;

            // 明確指定 UTF-8 編碼進行 MD5 運算，增加穩健性
            String md5Hex = DigestUtils.md5Hex(stringToSign.getBytes(StandardCharsets.UTF_8));
            String calculatedSignature = Base64.encodeBase64String(md5Hex.getBytes(StandardCharsets.UTF_8));

            if (!calculatedSignature.equals(request.getSign())) {
                logger.warn("簽名驗證失敗。part_code: {}, 傳入簽名: {}, 計算後簽名: {}", partCode, request.getSign(), calculatedSignature);

                partnerKeyRepository.findSenderCodeByPartCode(partCode).ifPresent(senderCode -> {
// ... existing code ...
```

> **重要提醒**：
> 這個修改需要您與傳送方（`ZENHUBFEILIKS`）進行溝通，**請他們務必在產生簽章時，也對 `data` 物件的 JSON 欄位按字母順序進行排序**，否則簽章仍然會不一致。

我已經更新了程式碼。您可以進行測試，並與您的合作夥伴協調此項變更。

---

_**User**_

你的說法有誤，原先 出庫單下發 那段 簽名驗證 跟我現在寫法是一樣的，但是出庫單下發的簽名驗證是正確的

---

_**Assistant**_



---

