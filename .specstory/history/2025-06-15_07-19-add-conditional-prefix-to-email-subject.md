<!-- Generated by SpecStory -->

# Add conditional prefix to email subject (2025-06-15 15:19:17)

_**User**_

@Codebase 發通知信的標題加一個條件，如果現在DB是連測試(10.1.1.15)則在標題開頭加上 {Testing, Please Ignore}，反之如果是正式(10.1.1.144)則在標題開頭加上 {Production, Please Check}

---

_**Assistant**_



---

好的，這就為您處理。

我將修改 `EmailService` 來實現您的需求。首先，我會注入資料庫連線 URL (`spring.datasource.url`)，然後新增一個方法來根據 URL 判斷目前的環境（測試或正式），最後在兩封通知信的標題前加上對應的前綴。

以下是 `src/main/java/com/zenitron/znt_inbound_api/service/EmailService.java` 的更新內容：

```java:src/main/java/com/zenitron/znt_inbound_api/service/EmailService.java
// ... existing code ...
public class EmailService {

    private static final Logger logger = LoggerFactory.getLogger(EmailService.class);

    private final JavaMailSender mailSender;
    private final String fromEmail;
    private final String dbUrl;

    @Autowired
    public EmailService(JavaMailSender mailSender, @Value("${spring.mail.from}") String fromEmail, @Value("${spring.datasource.url}") String dbUrl) {
        this.mailSender = mailSender;
        this.fromEmail = fromEmail;
        this.dbUrl = dbUrl;
    }

    private String getEnvironmentPrefix() {
        if (dbUrl != null) {
            if (dbUrl.contains("10.1.1.15")) {
                return "{Testing, Please Ignore} ";
            } else if (dbUrl.contains("10.1.1.144")) {
                return "{Production, Please Check} ";
            }
        }
        return "";
    }

    public void sendSignatureErrorEmail(List<String> to, String senderCode, String partnerKey, String calculatedSign, String receivedSign) {
        if (to == null || to.isEmpty()) {
// ... existing code ...
            SimpleMailMessage message = new SimpleMailMessage();
            message.setFrom(fromEmail);
            message.setTo(to.toArray(new String[0]));

            String subject = String.format("%sReceive [%s] EDI, SHIP key : [%s], sign Issue", getEnvironmentPrefix(), senderCode, partnerKey);
            message.setSubject(subject);

            String body = String.format(
// ... existing code ...
            logger.error("發送簽名錯誤通知郵件時發生錯誤。Sender Code: {}", senderCode, e);
        }
    }

    public void sendSuccessEmail(List<String> to, String senderCode, String refNo, String wmsNo) {
        if (to == null || to.isEmpty()) {
// ... existing code ...
        try {
            SimpleMailMessage message = new SimpleMailMessage();
            message.setFrom(fromEmail);
            message.setTo(to.toArray(new String[0]));

            String subject = String.format("%sReceive SHIP REF#[%s],WMS_NO#[%s] from [%s]", getEnvironmentPrefix(), refNo, wmsNo, senderCode);
            message.setSubject(subject);

            String body = "***EDI系統自動通知請勿回覆!***";
            message.setText(body);
// ... existing code ...
```

我已經更新了郵件服務，現在發出的郵件標題將會根據資料庫連線位址包含環境資訊。

---

_**User**_

@Codebase 在請求完成後的response訊息原本是 入庫單請求已成功接收，改成 出庫單發運請求已成功接收

---

_**Assistant**_



---

好的，這很簡單。我將修改 `InboundOrderController` 中的成功回應訊息。

以下是 `src/main/java/com/zenitron/znt_inbound_api/controller/InboundOrderController.java` 的更新：

```java:src/main/java/com/zenitron/znt_inbound_api/controller/InboundOrderController.java
// ... existing code ...
    @PostMapping
    public ResponseEntity<String> receiveInboundOrder(@Valid @RequestBody InboundOrderRequest request) {
        inboundOrderService.processInboundOrder(request);
        // 您可以根據業務需求自訂成功時的回應內容
        return ResponseEntity.ok("出庫單發運請求已成功接收");
    }
}
```

我已經將回應訊息從「入庫單請求已成功接收」更新為「出庫單發運請求已成功接收」。

---

_**User**_

@Codebase 剛測試之後有幾個地方要修正，
寫入 ZEN_B2B_JSON_SHIP 的 SEQ_ID 應該同一個REF_NO就是用一個SEQ_ID就好
寫入ZEN_B2B_ENVELOPE 的 條件應該是同一個REF_NO只會產生一筆

---

_**Assistant**_



---

好的，了解您的需求。目前的設計是為每一筆明細 (detail) 都產生一個新的 `SEQ_ID` 並寫入 `ZEN_B2B_ENVELOPE`，這顯然不符合「同一個 `REF_NO` 只產生一筆」的規則。

我將修改程式邏輯，確保對於同一個進來的請求 (以 `REF_NO` 為單位)：
1.  只產生一個唯一的 `SEQ_ID`。
2.  只寫入一筆資料到 `ZEN_B2B_ENVELOPE`。
3.  將請求中的每一筆明細 (detail) 都使用相同的 `SEQ_ID` 寫入 `ZEN_B2B_JSON_SHIP`。

我將會修改 `InboundOrderService` 和 `InboundOrderRepository`。

**1. 修改 `InboundOrderRepository`**

我會重構 `InboundOrderRepository`，將原本包裝在一起的 `saveShipmentData` 方法拆開，並將產生 `SEQ_ID` 的邏輯獨立出來。

```java:src/main/java/com/zenitron/znt_inbound_api/repository/InboundOrderRepository.java
package com.zenitron.znt_inbound_api.repository;

import com.zenitron.znt_inbound_api.dto.InboundOrderData;
import com.zenitron.znt_inbound_api.dto.InboundOrderDetail;
import com.zenitron.znt_inbound_api.dto.InboundOrderRequest;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

import java.util.Date;

@Repository
public class InboundOrderRepository {

    private final JdbcTemplate jdbcTemplate;

    @Autowired
    public InboundOrderRepository(JdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }

    public Long getNextSeqId() {
        String seqIdSql = "SELECT B2B.ZEN_B2B_SEQ.NEXTVAL FROM DUAL";
        Long nextSeqId = jdbcTemplate.queryForObject(seqIdSql, Long.class);

        if (nextSeqId == null) {
            throw new IllegalStateException("無法從序列 B2B.ZEN_B2B_SEQ 獲取新的 SEQ_ID");
        }
        return nextSeqId;
    }

    public void saveJsonShip(Long seqId, String senderCode, Date creationDate, InboundOrderData data, InboundOrderDetail detail) {
        String sql = "INSERT INTO B2B.ZEN_B2B_JSON_SHIP (" +
                "SEQ_ID, SENDER_CODE, RECEIVER_CODE, CREATION_DATE, REF_NO, SHIPPED_TIME, WMS_NO, WMS_UUID, BUSI_DATE, " +
                "BUYER_SKU_CODE, C_LPN_SEQ, C_LPN_UUID, C_VOL_HEIGHT, C_VOL_LENGTH, C_VOL_WIDTH, DATE_CODE, GROSS_WEIGHT, " +
                "LOT_NO, NET_WEIGHT, ORIGIN_COUNTRY_ENAME, OUT_PO_LINE, OUT_PO_NO, QTY, REF_NO1, SHIPPING_MARK, " +
                "SKU_CODE, STOCK_MODE, STOCK_UUID) " +
                "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";

        jdbcTemplate.update(sql,
                seqId,
                senderCode,
                "ZEN", // RECEIVER_CODE
                creationDate,
                data.getRefNo(),
                data.getShippedTime(),
                data.getWmsNo(),
                data.getWmsUuid(),
                data.getBusiDate(),
                detail.getBuyerSkuCode(),
                detail.getCLpnSeq(),
                detail.getCLpnUuid(),
                detail.getCVolHeight(),
                detail.getCVolLength(),
                detail.getCVolWidth(),
                detail.getDateCode(),
                detail.getGrossWeight(),
                detail.getLotNo(),
                detail.getNetWeight(),
                detail.getOriginCountryEname(),
                detail.getOutPoLine(),
                detail.getOutPoNo(),
                detail.getQty(),
                detail.getRefNo(), // detail's ref_no maps to REF_NO1
                detail.getShippingMark(),
                detail.getSkuCode(),
                detail.getStockMode(),
                detail.getStockUuid()
        );
    }

    public void saveEnvelope(Long seqId, String senderCode, InboundOrderRequest request, Date docDateTime) {
        InboundOrderData data = request.getData();
        String sql = "INSERT INTO B2B.ZEN_B2B_ENVELOPE (" +
                "SEQ_ID, SENDER_CODE, RECEIVER_CODE, SENDER_AP_ID, RECEIVER_AP_ID, SENDER_GS_ID, RECEIVER_GS_ID, " +
                "INTERCHANGE_NO, GROUP_NO, TRANSACTION_NO, DOC_NO, DOC_ID, DIRECTION, B2B_MSG_TYPE, DATASOURCE, " +
                "DOC_DATETIME, BATCH_PROCESS_ID, TRANS_FLAG, CONVERSATION_ID, CREATION_DATE, LAST_UPDATE_DATE, " +
                "REF_NO1, REF_NO2) " +
                "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";

        Date now = new Date();

        jdbcTemplate.update(sql,
                seqId,                          // SEQ_ID
                senderCode,                     // SENDER_CODE
                "ZEN",                          // RECEIVER_CODE
                request.getPartCode(),          // SENDER_AP_ID
                "ZEN",                          // RECEIVER_AP_ID
                senderCode,                     // SENDER_GS_ID
                "ZEN",                          // RECEIVER_GS_ID
                null,                           // INTERCHANGE_NO
                null,                           // GROUP_NO
                data.getRefNo(),                // TRANSACTION_NO
                data.getWmsNo(),                // DOC_NO
                String.valueOf(seqId),          // DOC_ID
                "IN",                           // DIRECTION
                "SHIP",                         // B2B_MSG_TYPE
                "EDI",                          // DATASOURCE
                docDateTime,                    // DOC_DATETIME
                data.getWmsUuid(),              // BATCH_PROCESS_ID
                "S",                            // TRANS_FLAG
                request.getSign(),              // CONVERSATION_ID
                now,                            // CREATION_DATE
                now,                            // LAST_UPDATE_DATE
                null,                           // REF_NO1
                null                            // REF_NO2
        );
    }
}
```

**2. 修改 `InboundOrderService`**

我會更新 `processInboundOrder` 方法，以符合新的資料儲存邏輯。

```java:src/main/java/com/zenitron/znt_inbound_api/service/InboundOrderService.java
// ... existing code ...
    @Transactional
    public void processInboundOrder(InboundOrderRequest request) {
        verifySignature(request);

        String senderCode = partnerKeyRepository.findSenderCodeByPartCode(request.getPartCode())
                .orElseThrow(() -> {
                    logger.error("無法從 part_code '{}' 反向查找 sender code", request.getPartCode());
                    // 這通常是資料設定問題，所以拋出一個會導致 500 錯誤的例外
                    return new IllegalStateException("伺服器內部錯誤：無法解析發送方代碼");
                });

        Date jsonCreationDate = parseDate(request.getRequestTime(), "request_time", true);
        
        InboundOrderData data = request.getData();
        Date docDateTime = parseDate(data.getShippedTime(), "shipped_time", false);

        // 1. 為此請求獲取一個唯一的 SEQ_ID
        Long seqId = inboundOrderRepository.getNextSeqId();

        // 2. 將 Envelope 資料寫入，每個請求只寫一次
        inboundOrderRepository.saveEnvelope(seqId, senderCode, request, docDateTime);

        // 3. 遍歷所有明細，使用相同的 SEQ_ID 寫入 JSON_SHIP 表
        for (InboundOrderDetail detail : data.getDetail()) {
            inboundOrderRepository.saveJsonShip(seqId, senderCode, jsonCreationDate, data, detail);
        }

        logger.info("成功將 {} 筆資料存入資料庫，參考編號 (ref_no): {}", data.getDetail().size(), data.getRefNo());

        // 發送成功通知郵件
        List<String> recipients = partnerKeyRepository.findRecipientsBySenderCode(senderCode);
        emailService.sendSuccessEmail(recipients, senderCode, data.getRefNo(), data.getWmsNo());

        logger.debug("完整請求內容: {}", request);
    }

    private Date parseDate(String dateString, String fieldName, boolean isRequired) {
// ... existing code ...
```

這樣修改後，就能確保同一個 `REF_NO` 的請求只會使用一個 `SEQ_ID` 並只產生一筆 `ENVELOPE` 資料了。

---

_**User**_

剛測試完怎麼ZEN_B2B_ENVELOPE insert 的 REF_NO1 沒有insert進去?

---

_**Assistant**_



---

您好，您說的沒錯！

經過檢查，在 `saveEnvelope` 方法中，`REF_NO1` 的值被固定設為 `null`，導致沒有將 `ref_no` 寫入 `ZEN_B2B_ENVELOPE` 表格。

我已經將它修正，現在會將請求資料中的 `ref_no` (`data.getRefNo()`) 寫入 `REF_NO1` 欄位。

以下是 `src/main/java/com/zenitron/znt_inbound_api/repository/InboundOrderRepository.java` 的修改：

```java:src/main/java/com/zenitron/znt_inbound_api/repository/InboundOrderRepository.java
// ... existing code ...
        jdbcTemplate.update(sql,
                seqId,                          // SEQ_ID
// ... existing code ...
                request.getSign(),              // CONVERSATION_ID
                now,                            // CREATION_DATE
                now,                            // LAST_UPDATE_DATE
                data.getRefNo(),                // REF_NO1
                null                            // REF_NO2
        );
    }
}
```

這樣修改後，`ZEN_B2B_ENVELOPE` 的 `REF_NO1` 欄位就會有正確的值了。

---

_**User**_

ZEN_B2B_ENVELOPE 的 REF_NO1對應的是 REQUEST_TIME，REF_NO2對應的是 BUSI_DATE

---

_**Assistant**_



---

